package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"fmt"
)

type BusinessObject struct {
	Description string `json:"Description"` // Description
	Field1      string `json:"Field1"`      // Field1
	Field2      string `json:"Field2"`      // Field2
	Field3      string `json:"Field3"`      // Field3
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the BusinessObject exists in the database.
func (businessObject *BusinessObject) Exists() bool {
	return businessObject._exists
}

// Deleted returns true when the BusinessObject has been marked for deletion from
// the database.
func (businessObject *BusinessObject) Deleted() bool {
	return businessObject._deleted
}

// Insert inserts the BusinessObject to the database.
func (businessObject *BusinessObject) Insert(ctx context.Context, db DB) error {
	switch {
	case businessObject._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case businessObject._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO dbo.BusinessObject (` +
		`Field1, Field2, Field3` +
		`) VALUES (` +
		`@p1, @p2, @p3` +
		`); SELECT ID = CONVERT(BIGINT, SCOPE_IDENTITY())`
	// run
	logf(sqlstr, businessObject.Field1, businessObject.Field2, businessObject.Field3)
	rows, err := db.QueryContext(ctx, sqlstr, businessObject.Field1, businessObject.Field2, businessObject.Field3)
	if err != nil {
		return logerror(err)
	}
	defer rows.Close()
	// retrieve id
	var id int64
	for rows.Next() {
		if err := rows.Scan(&id); err != nil {
			return logerror(err)
		}
	}
	if err := rows.Err(); err != nil {
		return logerror(err)
	} // set primary key
	businessObject.Field1 = fmt.Sprint(id)
	// set exists
	businessObject._exists = true
	return nil
}

// Update updates a BusinessObject in the database.
func (businessObject *BusinessObject) Update(ctx context.Context, db DB) error {
	switch {
	case !businessObject._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case businessObject._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with primary key
	const sqlstr = `UPDATE dbo.BusinessObject SET ` +
		`Field2 = @p1, Field3 = @p2 ` +
		`WHERE Field1 = @p3`
	// run
	logf(sqlstr, businessObject.Field2, businessObject.Field3, businessObject.Field1)
	if _, err := db.ExecContext(ctx, sqlstr, businessObject.Field2, businessObject.Field3, businessObject.Field1); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the BusinessObject to the database.
func (businessObject *BusinessObject) Save(ctx context.Context, db DB) error {
	if businessObject.Exists() {
		return businessObject.Update(ctx, db)
	}
	return businessObject.Insert(ctx, db)
}

// Upsert performs an upsert for BusinessObject.
func (businessObject *BusinessObject) Upsert(ctx context.Context, db DB) error {
	switch {
	case businessObject._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert using only Field1, Field2, Field3
	const sqlstr = `MERGE dbo.BusinessObject AS t ` +
		`USING (SELECT @p1 AS Field1, @p2 AS Field2, @p3 AS Field3) AS s ` +
		`ON t.Field1 = s.Field1 ` +
		`WHEN MATCHED THEN UPDATE SET t.Field2 = s.Field2, t.Field3 = s.Field3 ` +
		`WHEN NOT MATCHED THEN INSERT (Field1, Field2, Field3) VALUES (s.Field1, s.Field2, s.Field3);`
	// run
	logf(sqlstr, businessObject.Field1, businessObject.Field2, businessObject.Field3)
	if _, err := db.ExecContext(ctx, sqlstr, businessObject.Field1, businessObject.Field2, businessObject.Field3); err != nil {
		return logerror(err)
	}
	// set exists
	businessObject._exists = true
	return nil
}

// Delete deletes the BusinessObject from the database.
func (businessObject *BusinessObject) Delete(ctx context.Context, db DB) error {
	switch {
	case !businessObject._exists: // doesn't exist
		return nil
	case businessObject._deleted: // deleted
		return nil
	}
	// delete using only Field1 as the primary key
	const sqlstr = `DELETE FROM dbo.BusinessObject WHERE Field1 = @p1`
	// run
	logf(sqlstr, businessObject.Field1)
	if _, err := db.ExecContext(ctx, sqlstr, businessObject.Field1); err != nil {
		return logerror(err)
	}
	// set deleted
	businessObject._deleted = true
	return nil
}

// BusinessObjectByField1Field2 retrieves a BusinessObject from the database by Field1 and Field2.
// Custom function - not generated by xo
func BusinessObjectByField1Field2(ctx context.Context, db DB, field1, field2 string) (*BusinessObject, error) {
	const sqlstr = `SELECT ` +
		`Description, Field1, Field2, Field3 ` +
		`FROM dbo.BusinessObject ` +
		`WHERE Field1 = @p1 AND Field2 = @p2`

	// run query
	logf(sqlstr, field1, field2)
	rows, err := db.QueryContext(ctx, sqlstr, field1, field2)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()

	// process row
	var businessObject BusinessObject
	for rows.Next() {
		// scan
		if err := rows.Scan(&businessObject.Description, &businessObject.Field1, &businessObject.Field2, &businessObject.Field3); err != nil {
			return nil, logerror(err)
		}
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}

	// set exists
	businessObject._exists = true

	return &businessObject, nil
}
